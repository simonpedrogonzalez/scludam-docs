<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>scludam.detection &mdash; scludam 1.0.3 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            scludam
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">SCLUDAM (<strong>S</strong>tar <strong>CLU</strong>ster <strong>D</strong>etection <strong>A</strong>nd <strong>M</strong>embership estimation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Scludam Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../diagrams.html">Software diagrams</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">scludam</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">scludam.detection</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for scludam.detection</h1><div class="highlight"><pre>
<span></span><span class="c1"># scludam, Star CLUster Detection And Membership estimation package</span>
<span class="c1"># Copyright (C) 2022  Simón Pedro González</span>

<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>

<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>

<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;Module for density peak detection in numerical data.</span>

<span class="sd">This module provides density peak detection over numerical data and helper functions</span>
<span class="sd">for tasks such as defining filtering masks. The main API of</span>
<span class="sd">the module includes :class:`~scludam.detection.CountPeakDetector`,</span>
<span class="sd">:func:`~scludam.detection.default_mask` and :func:`~scludam.detection.extend_1dmask`,</span>
<span class="sd">which can be direcly imported from ``scludam``. Other functions and classes can be</span>
<span class="sd">imported from ``scludam.detection``.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">astropy.stats.sigma_clipping</span> <span class="kn">import</span> <span class="n">sigma_clipped_stats</span>
<span class="kn">from</span> <span class="nn">attrs</span> <span class="kn">import</span> <span class="n">define</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">validators</span>
<span class="kn">from</span> <span class="nn">beartype</span> <span class="kn">import</span> <span class="n">beartype</span>
<span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">NDArray</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">peak_local_max</span>

<span class="kn">from</span> <span class="nn">scludam.masker</span> <span class="kn">import</span> <span class="n">RangeMasker</span>
<span class="kn">from</span> <span class="nn">scludam.plots</span> <span class="kn">import</span> <span class="n">heatmap2D</span><span class="p">,</span> <span class="n">horizontal_lineplots</span>
<span class="kn">from</span> <span class="nn">scludam.type_utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">Numeric1DArrayLike</span><span class="p">,</span>
    <span class="n">Numeric2DArray</span><span class="p">,</span>
    <span class="n">OptionalArrayLike</span><span class="p">,</span>
    <span class="n">OptionalNumeric1DArrayLike</span><span class="p">,</span>
    <span class="n">_type</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="default_mask"><a class="viewcode-back" href="../../scludam.detection.html#scludam.detection.default_mask">[docs]</a><span class="nd">@beartype</span>
<span class="k">def</span> <span class="nf">default_mask</span><span class="p">(</span><span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a default mean mask for a given dimension.</span>

<span class="sd">    It returns a mean weighted mask with 5 elements per dimension,</span>
<span class="sd">    to be used as a filter for convolution. The sum of the</span>
<span class="sd">    mask weights is equal to 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dim : int</span>
<span class="sd">        Dimension of the mask.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray[np.number]</span>
<span class="sd">        Array with the mask.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The shape of the mask is chosen so it takes into account</span>
<span class="sd">    the values of neighboring bins, but not the value of the bin over</span>
<span class="sd">    which the mask is applied. The mask is intended to</span>
<span class="sd">    produce a good estimate of the local density of the background</span>
<span class="sd">    of the bin over which it is applied. This mask is used in the</span>
<span class="sd">    method applied by González-Alejo (2020) [1]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Alejo, A.D., González, J.F., González, S. P. (2020).</span>
<span class="sd">        Estudio de membresía de cúmulos estelares utilizando Gaia DR2.</span>
<span class="sd">        Cuaderno de Resúmenes 62a Reunión Anual Asociación</span>
<span class="sd">        Argentina de Astronomía, Rosario, Provincia de Santa Fe, 64.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. literalinclude:: ../../examples/detection/default_mask.py</span>
<span class="sd">        :language: python</span>
<span class="sd">        :linenos:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">))))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="n">dim</span><span class="p">)</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">indexes</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">indexes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">cond</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cond</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">))]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">mask</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_convolve</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">OptionalArrayLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">c_filter</span><span class="p">:</span> <span class="nb">callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="n">c_filter</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">c_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="c1"># unused</span>
<span class="c1"># def var_filter(data, mask=None, *args, **kwargs):</span>
<span class="c1">#     if mask is not None:</span>
<span class="c1">#         kwargs[&quot;footprint&quot;] = mask != 0</span>
<span class="c1">#     return _convolve(</span>
<span class="c1">#         data,</span>
<span class="c1">#         c_filter=ndimage.generic_filter,</span>
<span class="c1">#         function=np.var,</span>
<span class="c1">#         *args,</span>
<span class="c1">#         **kwargs,</span>
<span class="c1">#     )</span>


<span class="c1"># unused</span>
<span class="c1"># def std_filter(data, mask=None, *args, **kwargs):</span>
<span class="c1">#     if mask is not None:</span>
<span class="c1">#         kwargs[&quot;footprint&quot;] = mask != 0</span>
<span class="c1">#     return _convolve(</span>
<span class="c1">#         data,</span>
<span class="c1">#         c_filter=ndimage.generic_filter,</span>
<span class="c1">#         function=np.std,</span>
<span class="c1">#         *args,</span>
<span class="c1">#         **kwargs,</span>
<span class="c1">#     )</span>


<div class="viewcode-block" id="fast_std_filter"><a class="viewcode-back" href="../../scludam.detection.html#scludam.detection.fast_std_filter">[docs]</a><span class="nd">@beartype</span>
<span class="k">def</span> <span class="nf">fast_std_filter</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fast standard deviation filter.</span>

<span class="sd">    To be applied over an image or histogram.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : NDArray</span>
<span class="sd">        Image or n-dimensional histogram.</span>
<span class="sd">    mask : ArrayLike</span>
<span class="sd">        Mask to be used for the convolution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        Filtered image or histogram of the same dimensions.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Is possible to pass kwargs to the ``scipy.ndimage.convolve`` function.</span>
<span class="sd">    Its default border mode is &#39;reflect&#39;.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u_x2</span> <span class="o">=</span> <span class="n">_convolve</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">ux_2</span> <span class="o">=</span> <span class="n">_convolve</span><span class="p">(</span><span class="n">data</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">ux_2</span> <span class="o">-</span> <span class="n">u_x2</span> <span class="o">*</span> <span class="n">u_x2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span></div>


<div class="viewcode-block" id="get_histogram_bins"><a class="viewcode-back" href="../../scludam.detection.html#scludam.detection.get_histogram_bins">[docs]</a><span class="nd">@beartype</span>
<span class="k">def</span> <span class="nf">get_histogram_bins</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">Numeric2DArray</span><span class="p">,</span>
    <span class="n">bin_shape</span><span class="p">:</span> <span class="n">Numeric1DArrayLike</span><span class="p">,</span>
    <span class="n">offsets</span><span class="p">:</span> <span class="n">OptionalNumeric1DArrayLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get histogram bins and edges given a bin shape and data.</span>

<span class="sd">    The method takes into account the data max and min values</span>
<span class="sd">    for each dimension and the bin shape to calculate the amount</span>
<span class="sd">    of bins and the edges to be used of an histogram. Half a bin</span>
<span class="sd">    is added to each extremum to avoid bins edges to be exactly</span>
<span class="sd">    on the data extremums.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : Numeric2DArray</span>
<span class="sd">        Data to be used to get the histogram bins.</span>
<span class="sd">    bin_shape : Numeric1DArrayLike</span>
<span class="sd">        Bin shape (each dimension) to be used.</span>
<span class="sd">    offsets : OptionalNumeric1DArrayLike, optional</span>
<span class="sd">        Offsets to be added to the edges, by default ``None``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (Numeric1DArray, Numeric2DArray)</span>
<span class="sd">        Number of bins and edges.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1"># calculate the margins which are added to the range in order</span>
    <span class="c1"># to fit a number of bins that is integer</span>
    <span class="n">margins</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span>
            <span class="n">bin_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="o">-</span> <span class="nb">float</span><span class="p">(</span>
                <span class="n">Decimal</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()))</span>
                <span class="o">%</span> <span class="n">Decimal</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">bin_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="c1"># add base margins</span>
    <span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="n">margins</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="n">margins</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="n">offsets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">((</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">bin_shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bins</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span></div>


<div class="viewcode-block" id="histogram"><a class="viewcode-back" href="../../scludam.detection.html#scludam.detection.histogram">[docs]</a><span class="nd">@beartype</span>
<span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">Numeric2DArray</span><span class="p">,</span>
    <span class="n">bin_shape</span><span class="p">:</span> <span class="n">Numeric1DArrayLike</span><span class="p">,</span>
    <span class="n">offsets</span><span class="p">:</span> <span class="n">OptionalNumeric1DArrayLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get a histogram given a bin shape and data.</span>

<span class="sd">    Uses :func:`~scludam.detection.get_histogram_bins` results</span>
<span class="sd">    to create a n-dimensional histogram.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : Numeric2DArray</span>
<span class="sd">        Data to be used.</span>
<span class="sd">    bin_shape : Numeric1DArrayLike</span>
<span class="sd">        Bin shape (in each dimension) to be used.</span>
<span class="sd">    offsets : OptionalNumeric1DArrayLike, optional</span>
<span class="sd">        Offsets to shift the edges of the histogram, by default ``None``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (NDArray, NDArray)</span>
<span class="sd">        Histogram and edges.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">bins</span><span class="p">,</span> <span class="n">ranges</span> <span class="o">=</span> <span class="n">get_histogram_bins</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bin_shape</span><span class="p">,</span> <span class="n">offsets</span><span class="p">)</span>
    <span class="n">hist</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">ranges</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hist</span><span class="p">,</span> <span class="n">edges</span></div>


<div class="viewcode-block" id="nyquist_offsets"><a class="viewcode-back" href="../../scludam.detection.html#scludam.detection.nyquist_offsets">[docs]</a><span class="nd">@beartype</span>
<span class="k">def</span> <span class="nf">nyquist_offsets</span><span class="p">(</span><span class="n">bin_shape</span><span class="p">:</span> <span class="n">Numeric1DArrayLike</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get offsets for shifting a histogram.</span>

<span class="sd">    Get all possible offsets for a given bin shape, to be used</span>
<span class="sd">    to shift the histogram edges following the Nyquist spatial</span>
<span class="sd">    sampling interval. The offsets are calculated as the half of the</span>
<span class="sd">    bin shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bin_shape : Numeric1DArrayLike</span>
<span class="sd">        Bin shape (in each dimension).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Numeric2DArray</span>
<span class="sd">        Array of shape (n_combinations, n_dimensions) with the</span>
<span class="sd">        possible offsets.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dim</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bin_shape</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">combinations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">combinations</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_are_indices_adjacent</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Numeric1DArrayLike</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Numeric1DArrayLike</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>


<div class="viewcode-block" id="extend_1dmask"><a class="viewcode-back" href="../../scludam.detection.html#scludam.detection.extend_1dmask">[docs]</a><span class="nd">@beartype</span>
<span class="k">def</span> <span class="nf">extend_1dmask</span><span class="p">(</span><span class="n">mask</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extend a 1-dimensional filtering mask to a n-dimensional mask.</span>

<span class="sd">    From a numeric filtering 1D mask, the function uses the</span>
<span class="sd">    outer product to</span>
<span class="sd">    extend it to a n-dimensional one. The resulting mask is</span>
<span class="sd">    the combination of n 1D masks orthogonal to</span>
<span class="sd">    each other. The sum of the resulting mask is equal to 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mask : ArrayLike</span>
<span class="sd">        1D mask to be extended.</span>
<span class="sd">    dim : int</span>
<span class="sd">        Dimension of the mask to be extended to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        Extended mask.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. literalinclude:: ../../examples/detection/extend_1dmask.py</span>
<span class="sd">        :language: python</span>
<span class="sd">        :linenos:</span>
<span class="sd">    .. image:: ../../examples/detection/extend_1dmask.png</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">mi</span> <span class="o">=</span> <span class="n">m1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">mi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">mi</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mi</span> <span class="o">/</span> <span class="n">mi</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>


<span class="k">def</span> <span class="nf">_get_higher_score_offset_per_peak</span><span class="p">(</span><span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="n">scores</span><span class="p">:</span> <span class="n">List</span><span class="p">):</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="n">scores</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;indices and scores must have the same length&quot;</span><span class="p">)</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">))),</span> <span class="n">indices</span><span class="p">,</span> <span class="n">scores</span><span class="p">))</span>
    <span class="n">best</span> <span class="o">=</span> <span class="p">[</span><span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">peak</span> <span class="o">=</span> <span class="n">peaks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ii</span><span class="p">,</span> <span class="n">iindex</span><span class="p">,</span> <span class="n">iscore</span> <span class="o">=</span> <span class="n">peak</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">best</span><span class="p">):</span>
            <span class="n">ji</span><span class="p">,</span> <span class="n">jindex</span><span class="p">,</span> <span class="n">jscore</span> <span class="o">=</span> <span class="n">best</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ji</span> <span class="o">!=</span> <span class="n">ii</span> <span class="ow">and</span> <span class="n">_are_indices_adjacent</span><span class="p">(</span><span class="n">iindex</span><span class="p">,</span> <span class="n">jindex</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">iscore</span> <span class="o">&gt;</span> <span class="n">jscore</span><span class="p">:</span>
                    <span class="c1"># keep same jindex but update peak</span>
                    <span class="c1"># so it does not follow a path of</span>
                    <span class="c1"># adjacent best peaks indefinitely</span>
                    <span class="n">best</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jindex</span><span class="p">,</span> <span class="n">iscore</span><span class="p">]</span>
                <span class="k">break</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">best</span><span class="p">):</span>
            <span class="n">best</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>

    <span class="n">best</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">best</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">best</span><span class="p">])</span>


<div class="viewcode-block" id="DetectionResult"><a class="viewcode-back" href="../../scludam.detection.html#scludam.detection.DetectionResult">[docs]</a><span class="nd">@define</span>
<span class="k">class</span> <span class="nc">DetectionResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Result of a detection run.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    centers : Numeric2DArray</span>
<span class="sd">        Centers of the detected peaks. Are calculated using</span>
<span class="sd">        sigma clipped median over the data delimited by the</span>
<span class="sd">        ``edges``.</span>
<span class="sd">    edges : Numeric2DArray</span>
<span class="sd">        Edges that delimit the data used to calculate the</span>
<span class="sd">        centers. It is taken as a bin shape in each direction,</span>
<span class="sd">        in each dimension.</span>
<span class="sd">    scores : Numeric1DArray</span>
<span class="sd">        Scores of the detected peaks. The results are sorted</span>
<span class="sd">        by score in descending order.</span>
<span class="sd">    counts : Numeric1DArray</span>
<span class="sd">        Number of data points in the bin that represents the</span>
<span class="sd">        peak.</span>
<span class="sd">    sigmas : Numeric1DArray</span>
<span class="sd">        Sigma of the detected peaks. Currently arbitrarily set</span>
<span class="sd">        as the bin shape in each dimension.</span>
<span class="sd">    offsets : Numeric2DArray</span>
<span class="sd">        Offsets used for detecting each peak.</span>
<span class="sd">    indices : Numeric2DArray</span>
<span class="sd">        Indices of the detected peaks in the histogram.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">centers</span><span class="p">:</span> <span class="n">Numeric2DArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">sigmas</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">scores</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">counts</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">edges</span><span class="p">:</span> <span class="n">Numeric2DArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">offsets</span><span class="p">:</span> <span class="n">Numeric2DArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Numeric2DArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span></div>


<span class="c1"># TODO: add a plot for the result</span>
<div class="viewcode-block" id="CountPeakDetector"><a class="viewcode-back" href="../../scludam.detection.html#scludam.detection.CountPeakDetector">[docs]</a><span class="nd">@define</span>
<span class="k">class</span> <span class="nc">CountPeakDetector</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Count peak detector class.</span>

<span class="sd">    Uses an n-dimensional histogram (array) to detect density</span>
<span class="sd">    peaks in the input data.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    bin_shape : Numeric1DArrayLike</span>
<span class="sd">        Bin shape (in each dimension) to be used to create the histogram.</span>
<span class="sd">    mask: OptionalArrayLike, optional</span>
<span class="sd">        Mask to be used as in the filtering operations, by default uses</span>
<span class="sd">        :func:`~scludam.detection.default_mask` with data dimensions.</span>
<span class="sd">        The mask must have same dimensions as the data and its weights</span>
<span class="sd">        must sum to 1 and be appropriate for smoothing.</span>
<span class="sd">    nyquist_offsets : bool, optional</span>
<span class="sd">        If ``True``, the Nyquist spatial sampling interval is used to shift the</span>
<span class="sd">        histogram edges, by default ``True``. It helps to underestimating</span>
<span class="sd">        the bin count due to an arbitrarily</span>
<span class="sd">        chosen bin edge shift. It uses :func:`~scludam.detection.nyquist_offsets`.</span>
<span class="sd">    min_count: Number, optional</span>
<span class="sd">        Mimimum count for a bin to be elegible as a peak, by default 10. Also used to</span>
<span class="sd">        ``remove_low_density_regions`` if that option is enabled.</span>
<span class="sd">    remove_low_density_regions : bool, optional</span>
<span class="sd">        If ``True``, low density bins are removed from the histogram, by default</span>
<span class="sd">        True. It removes low density bins from the edges of the histogram,</span>
<span class="sd">        trimming down the region of interest and reducing the size of the</span>
<span class="sd">        histogram, which in turn reduces memory usage for sparse data. It uses</span>
<span class="sd">        the ``min_count`` value as the threshold. It also keeps bins that are in the</span>
<span class="sd">        neigborhood of a valid (dense) bin so the filtering operation can be applied</span>
<span class="sd">        to the remaining bins correctly. The neighborhood is defined by the size of</span>
<span class="sd">        the ``mask`` to be used for the filtering operations.</span>
<span class="sd">    min_dif: Number, optional</span>
<span class="sd">        Minimum difference between the background and the bin count for a bin to be</span>
<span class="sd">        elegible as peak, by default 10. The formula used is:</span>
<span class="sd">        ``elegible if histogram - background &gt; min_dif`` where ``background`` is</span>
<span class="sd">        obtained by using filtering the histogram with the provided ``mask``.</span>
<span class="sd">    min_sigma_dif: Number, optional</span>
<span class="sd">        Sigma value to be used to calculate difference between the background and the</span>
<span class="sd">        bin count for a bin to be elegible as peak, by default ``None`` (deactivated).</span>
<span class="sd">        The formula used is:</span>
<span class="sd">        ``elegible if histogram - background &gt; min_sigma_dif*std`` where ``background``</span>
<span class="sd">        is obtained by using filtering the histogram with the provided</span>
<span class="sd">        ``mask``. ``std``</span>
<span class="sd">        represents the standard deviation in a window surrounding the bin, calculated</span>
<span class="sd">        according to the ``norm_mode`` parameter.</span>
<span class="sd">    min_score: Number, optional</span>
<span class="sd">        Minimum score for a bin to be elegible as peak, by default 2. The score is</span>
<span class="sd">        calculated as the standardized difference between the bin count and the</span>
<span class="sd">        background:</span>
<span class="sd">        ``score = (histogram - background) / std`` where ``background`` is obtained by</span>
<span class="sd">        using filtering the histogram with the provided ``mask``. ``std`` is</span>
<span class="sd">        calculated according to the ``norm_mode`` parameter.</span>
<span class="sd">    max_n_peaks: Number, optional</span>
<span class="sd">        Maximum number of peaks to be detected, by default 10. Use ``np.inf``</span>
<span class="sd">        to detect all peaks.</span>
<span class="sd">    min_interpeak_distance: int, optional</span>
<span class="sd">        Minimum number of bins between peaks, by default 1.</span>
<span class="sd">    norm_mode: str, optional</span>
<span class="sd">        Mode to be used to get the standard deviation used in the</span>
<span class="sd">        score calculation, by default &quot;std&quot;. Can be one of the following:</span>

<span class="sd">        #. &quot;std&quot;: Standard deviation of the ``histogram - background`` calculated</span>
<span class="sd">           using the ``mask`` provided and</span>
<span class="sd">           :func:`~scludam.detection.fast_std_filter`</span>

<span class="sd">        #. &quot;approx&quot;: Approximation [1]_ to the standard deviation taking into account</span>
<span class="sd">           how the ``sharp = histogram - background`` is obtained.</span>

<span class="sd">            *   An common estimate of the standard deviation of an histogram</span>
<span class="sd">                is the root square of the bin count: ``std(h) = sqrt(h)``.</span>
<span class="sd">            *   According to the uncertainty propagation:</span>
<span class="sd">                if ``s = h - b``, then</span>
<span class="sd">                ``std(s) = sqrt(var(h) + var(b) - 2*cov(h,b))``.</span>
<span class="sd">            *   Considering ``2*cov(h,b)~0``, the approximation is:</span>
<span class="sd">                ``std(s) = sqrt(h + b)``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm used is based in the following steps:</span>

<span class="sd">    #. Remove the data corresponding to low density regions from the edges</span>
<span class="sd">       to the center, until a dense enough bin is found,</span>
<span class="sd">       as described in the ``remove_low_density_regions`` parameter.</span>
<span class="sd">    #. Calculate all possible offsets for the histogram edges, using the</span>
<span class="sd">       Nyquist spatial sampling interval. The region surveyed is subdivided into</span>
<span class="sd">       a rectilinear grid of overlapping hypercubes separated by half the side</span>
<span class="sd">       length of an individual bin [2]_ [3]_ [4]_.</span>
<span class="sd">    #. Instead of creating one histogram including all possible offsets, which</span>
<span class="sd">       can be very large when dimensionality increases, an histogram is created</span>
<span class="sd">       for each possible offset. Per histogram, the following steps are preformed:</span>

<span class="sd">        #.  Estimate the background density, convolving the histogram with the</span>
<span class="sd">            provided ``mask``, smoothing the histogram over adjacent bins inside</span>
<span class="sd">            a window defined by the mask size [2]_ [5]_ [6]_.</span>
<span class="sd">        #.  Calculate the excess of data points in each bin as the difference</span>
<span class="sd">            between the bin count and the background density. This is equivalent</span>
<span class="sd">            to applying a high-pass filter to the histogram. It should be noted</span>
<span class="sd">            that the excess count using this</span>
<span class="sd">            method can be poorly estimated, specially when the bin shape used</span>
<span class="sd">            is not appropriate.</span>
<span class="sd">        #.  Calculate the score of each bin as the normalized excess count, using</span>
<span class="sd">            the methods described in the ``norm_mode`` parameter.</span>
<span class="sd">        #.  Apply ``min_count``, ``min_sigma_dif``, ``min_dif`` and</span>
<span class="sd">            ``min_interpeak_distance`` constraints and find peaks in the n-dimensional</span>
<span class="sd">            score histogram.</span>

<span class="sd">    #. Take the peaks found in each shifted histogram and merge them into a</span>
<span class="sd">       a single list, taking only the higher score shift for each peak. The list</span>
<span class="sd">       is sorted in descending order by score.</span>

<span class="sd">    The fundamental parameter of the method is ``bin_shape``.</span>
<span class="sd">    In general, the shape must be chosen as the span in each dimension</span>
<span class="sd">    of the object to be detected.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [2] Schmeja, S. (2011). Identifying star clusters in a field:</span>
<span class="sd">        A comparison of different algorithms. Astronomische Nachrichten,</span>
<span class="sd">        332, 172-184. doi: 10.1002/asna.201011484</span>
<span class="sd">    .. [3] Lada, E. A., Lada, C. J. (1995). Near-infrared images of IC</span>
<span class="sd">        348 and the luminosity functions of young embedded star clusters.</span>
<span class="sd">        The Astrophysical Journal, 109.</span>
<span class="sd">    .. [4] Nanda Kumar, M. S., Kamath U. S., and Davis, C. J. (2004). Embedded</span>
<span class="sd">        star clusters in the W51 giant molecular cloud. Monthly Notices of the</span>
<span class="sd">        Royal Astronomical Society, 353, 1025–1034.</span>
<span class="sd">        doi:10.1111/j.1365-2966.2004.08143.x</span>
<span class="sd">    .. [5] Lada, E. A., DePoy, D. L., Evans, N. J. y Gatley, I. (1991).</span>
<span class="sd">        Micron survey in the LI630 molecular cloud. The Astrophysical Journal,</span>
<span class="sd">        371, 171-182.</span>
<span class="sd">    .. [6] Karampelas, A., Dapergolas, A., Kontizas, E., Livanou, E., Kontizas,</span>
<span class="sd">        M., Bellas-Velidis, I. y Vílchez, J. M. (2009). Star complexes and stellar</span>
<span class="sd">        populations in NGC 6822: Comparison with the Magellanic Clouds.</span>
<span class="sd">        Astronomy and Astrophysics, 497, 703–711.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. literalinclude:: ../../examples/detection/count_peak_detector.py</span>
<span class="sd">        :language: python</span>
<span class="sd">        :linenos:</span>
<span class="sd">    .. image:: ../../examples/detection/count_peak_detector.png</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bin_shape</span><span class="p">:</span> <span class="n">Numeric1DArrayLike</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">validator</span><span class="o">=</span><span class="n">_type</span><span class="p">(</span><span class="n">Numeric1DArrayLike</span><span class="p">))</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">OptionalArrayLike</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">validator</span><span class="o">=</span><span class="n">_type</span><span class="p">(</span><span class="n">OptionalArrayLike</span><span class="p">))</span>
    <span class="n">nyquist_offset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">min_count</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">min_dif</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">min_sigma_dif</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">min_score</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">max_n_peaks</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">min_interpeak_dist</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">validator</span><span class="o">=</span><span class="n">_type</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
    <span class="n">remove_low_density_regions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">validator</span><span class="o">=</span><span class="n">_type</span><span class="p">(</span><span class="nb">bool</span><span class="p">))</span>
    <span class="n">norm_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="n">validator</span><span class="o">=</span><span class="n">validators</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="s2">&quot;approx&quot;</span><span class="p">]))</span>
    <span class="n">_offsets</span><span class="p">:</span> <span class="n">OptionalArrayLike</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_last_result</span><span class="p">:</span> <span class="n">DetectionResult</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_data</span><span class="p">:</span> <span class="n">Numeric2DArray</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_remove_low_density_regions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Numeric2DArray</span><span class="p">):</span>
        <span class="n">obs</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># calculate data ranges in each dimension, taking into account</span>
        <span class="c1"># that bin number must be integer</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">ranges</span> <span class="o">=</span> <span class="n">get_histogram_bins</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">shifts</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                            </span><span class="sd">&quot;&quot;&quot;No bin passed minimum density check.</span>
<span class="sd">                            Check min_count parameter.&quot;&quot;&quot;</span>
                        <span class="p">)</span>
                    <span class="n">slice_ranges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>
                    <span class="c1"># if j = 0 -&gt; upper limit = lower limit + bin shape</span>
                    <span class="c1"># if j = 1 -&gt; lower limit = upper limit - bin shape</span>
                    <span class="n">slice_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">j</span><span class="p">))]</span> <span class="o">=</span> <span class="n">slice_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">shifts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">data_slice</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">RangeMasker</span><span class="p">(</span><span class="n">limits</span><span class="o">=</span><span class="n">slice_ranges</span><span class="p">)</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="n">data_slice</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">slice_histogram</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">(</span><span class="n">data_slice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="p">)</span>
                        <span class="c1"># if any bin has min required count, stop trimming</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">slice_histogram</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_count</span><span class="p">):</span>
                            <span class="k">break</span>
                        <span class="c1"># else, move limit towards the center and continue</span>
                    <span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">slice_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">j</span><span class="p">))]</span>

        <span class="c1"># extend ranges half mask shape in each direction so data that belongs to</span>
        <span class="c1"># an invalid bin can contribute in a border valid bin when the mask is applied</span>
        <span class="n">mask_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">half_mask_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mask_shape</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ranges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ranges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">half_mask_shape</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span>
        <span class="n">ranges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ranges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">half_mask_shape</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span>

        <span class="c1"># trim data and return</span>
        <span class="n">trimmed_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">RangeMasker</span><span class="p">(</span><span class="n">limits</span><span class="o">=</span><span class="n">ranges</span><span class="p">)</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">trimmed_data</span>

    <span class="k">def</span> <span class="nf">_set_nyquist_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nyquist_offset</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
            <span class="n">combinations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">combinations</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="CountPeakDetector.detect"><a class="viewcode-back" href="../../scludam.detection.html#scludam.detection.CountPeakDetector.detect">[docs]</a>    <span class="nd">@beartype</span>
    <span class="k">def</span> <span class="nf">detect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Numeric2DArray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Detect peaks in the provided data.</span>

<span class="sd">        Uses the configuration provided in the class attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : Numeric2DArray</span>
<span class="sd">            Numerical data to be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DetectionResult</span>
<span class="sd">            Instance containing the detected peaks.</span>


<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``remove_low_density_regions`` is used and no bin passes</span>
<span class="sd">            the density check, the min_count is probably too low.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``data``, ``bin_shape`` and ``mask`` dimensions do not match.</span>
<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        UserWarning</span>
<span class="sd">            If histogram has too few bins in some dimension, the</span>
<span class="sd">            filtering operations can still be applied but prone to border effects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data array must have 2 dimensions&quot;</span><span class="p">)</span>
        <span class="n">obs</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># mask setup</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">default_mask</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span>

        <span class="c1"># check mask and bin shape are compatible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mask does not match data dimensions&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bin_shape does not match data dimensions&quot;</span><span class="p">)</span>

        <span class="c1"># remove points in low density regions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_low_density_regions</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_count</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_low_density_regions</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="c1"># set nyquist offsets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_nyquist_offsets</span><span class="p">()</span>

        <span class="c1"># get histogram ranges and bin numbers</span>
        <span class="n">bins</span><span class="p">,</span> <span class="n">ranges</span> <span class="o">=</span> <span class="n">get_histogram_bins</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="p">)</span>

        <span class="c1"># set peak detection parameters</span>
        <span class="n">peak_detection_params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Histogram has too few bins in some dimensions: bin numbers are </span><span class="si">{</span><span class="n">bins</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">peak_detection_params</span><span class="p">[</span><span class="s2">&quot;exclude_border&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">peak_detection_params</span><span class="p">[</span><span class="s2">&quot;exclude_border&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_interpeak_dist</span><span class="p">:</span>
            <span class="n">peak_detection_params</span><span class="p">[</span><span class="s2">&quot;min_distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_interpeak_dist</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_score</span><span class="p">:</span>
            <span class="n">peak_detection_params</span><span class="p">[</span><span class="s2">&quot;threshold_abs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_score</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_n_peaks</span><span class="p">:</span>
            <span class="n">peak_detection_params</span><span class="p">[</span><span class="s2">&quot;num_peaks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_n_peaks</span>

        <span class="c1"># detection</span>
        <span class="n">g_centers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">g_scores</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">g_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">g_sigmas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">g_counts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">g_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">g_offsets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span><span class="p">:</span>
            <span class="n">hist</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="n">smoothed</span> <span class="o">=</span> <span class="n">_convolve</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">sharp</span> <span class="o">=</span> <span class="n">hist</span> <span class="o">-</span> <span class="n">smoothed</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_mode</span> <span class="o">==</span> <span class="s2">&quot;approx&quot;</span><span class="p">:</span>
                <span class="c1"># approx explanation</span>
                <span class="c1"># err_hist = sqrt(hist)</span>
                <span class="c1"># because:</span>
                <span class="c1"># estimate of std: std[vhat] = sqrt(vhat) = sqrt(n)</span>
                <span class="c1"># error bars are given by the square root</span>
                <span class="c1"># of the number of entries in each bin of the histogram</span>
                <span class="c1"># err_smoothed = std(smoothed) = sqrt(smoothed)</span>
                <span class="c1"># sharp = hist - smoothed so</span>
                <span class="c1"># err_sharp = sqrt(err_hist^2 + err_smoothed^2 - ...)</span>
                <span class="c1"># because:</span>
                <span class="c1"># std[a - b] = sqrt(varianza(a) + varianza(b) - 2*covarianza(a,b))</span>
                <span class="c1"># according to: https://en.wikipedia.org/wiki/Propagation_of_uncertainty</span>
                <span class="c1"># covarianza(a,b) = varianza(a) * varianza(b) * corrcoef(a,b)</span>
                <span class="c1"># as normalized = sharp / err_sharp</span>
                <span class="c1"># +1 is added to avoid zero division errors</span>
                <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">smoothed</span> <span class="o">+</span> <span class="n">hist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_mode</span> <span class="o">==</span> <span class="s2">&quot;std&quot;</span><span class="p">:</span>
                <span class="c1"># directly gettig std</span>
                <span class="n">std</span> <span class="o">=</span> <span class="n">fast_std_filter</span><span class="p">(</span><span class="n">sharp</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">normalized</span> <span class="o">=</span> <span class="n">sharp</span> <span class="o">/</span> <span class="n">std</span>

            <span class="c1"># TODO: remove, other way of getting the std approx</span>
            <span class="c1"># n4 = sharp / np.sqrt(std**2 + fast_std_filter(smoothed, mask=mask)**2 + 1)</span>

            <span class="n">detection_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">normalized</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_dif</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">detection_img</span><span class="p">[</span><span class="n">sharp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_dif</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sigma_dif</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">detection_img</span><span class="p">[</span><span class="n">sharp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sigma_dif</span> <span class="o">*</span> <span class="n">std</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">clusters_idx</span> <span class="o">=</span> <span class="n">peak_local_max</span><span class="p">(</span><span class="n">detection_img</span><span class="p">,</span> <span class="o">**</span><span class="n">peak_detection_params</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">peak_count</span> <span class="o">=</span> <span class="n">clusters_idx</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">peak_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

                <span class="n">iter_indcs</span> <span class="o">=</span> <span class="n">clusters_idx</span><span class="o">.</span><span class="n">T</span>
                <span class="n">iter_counts</span> <span class="o">=</span> <span class="n">sharp</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">clusters_idx</span><span class="p">)]</span>
                <span class="n">iter_scores</span> <span class="o">=</span> <span class="n">normalized</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">clusters_idx</span><span class="p">)]</span>

                <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">[</span>
                        <span class="p">(</span>
                            <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">clusters_idx</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                            <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">clusters_idx</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">peak_count</span><span class="p">)</span>
                <span class="p">]</span>

                <span class="n">iter_edges</span> <span class="o">=</span> <span class="n">limits</span>

                <span class="n">subsets</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">RangeMasker</span><span class="p">(</span><span class="n">limits</span><span class="o">=</span><span class="n">limits</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">peak_count</span><span class="p">)</span>
                <span class="p">]</span>

                <span class="c1"># stats may be useless if other center and sigma are calculated</span>
                <span class="c1"># afterwards e.g. meanshift and profile analysis</span>
                <span class="n">statistics</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">[</span>
                            <span class="n">sigma_clipped_stats</span><span class="p">(</span>
                                <span class="n">subsets</span><span class="p">[</span><span class="n">j</span><span class="p">][:,</span> <span class="n">i</span><span class="p">],</span>
                                <span class="n">cenfunc</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">,</span>
                                <span class="n">stdfunc</span><span class="o">=</span><span class="s2">&quot;mad_std&quot;</span><span class="p">,</span>
                                <span class="n">maxiters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                        <span class="p">]</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">peak_count</span><span class="p">)</span>
                    <span class="p">]</span>
                <span class="p">)</span>

                <span class="n">iter_centers</span> <span class="o">=</span> <span class="n">statistics</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>

                <span class="n">g_indices</span> <span class="o">+=</span> <span class="n">iter_indcs</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">g_centers</span> <span class="o">+=</span> <span class="n">iter_centers</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">g_scores</span> <span class="o">+=</span> <span class="n">iter_scores</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">g_edges</span> <span class="o">+=</span> <span class="n">iter_edges</span>
                <span class="n">g_sigmas</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">peak_count</span><span class="p">)]</span>
                <span class="n">g_counts</span> <span class="o">+=</span> <span class="n">iter_counts</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">g_offsets</span> <span class="o">+=</span> <span class="p">[</span><span class="n">offset</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">peak_count</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_result</span> <span class="o">=</span> <span class="n">DetectionResult</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_result</span><span class="p">)</span>

        <span class="c1"># compare same peaks in different histogram offsets</span>
        <span class="c1"># and return most sifnificant peak for all offsets</span>
        <span class="n">g_ind</span> <span class="o">=</span> <span class="n">_get_higher_score_offset_per_peak</span><span class="p">(</span><span class="n">g_indices</span><span class="p">,</span> <span class="n">g_scores</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_n_peaks</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="n">g_ind</span> <span class="o">=</span> <span class="n">g_ind</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_n_peaks</span><span class="p">]</span>

        <span class="n">g_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g_centers</span><span class="p">)[</span><span class="n">g_ind</span><span class="p">]</span>
        <span class="n">g_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g_scores</span><span class="p">)[</span><span class="n">g_ind</span><span class="p">]</span>
        <span class="n">g_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g_edges</span><span class="p">)[</span><span class="n">g_ind</span><span class="p">]</span>
        <span class="n">g_sigmas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g_sigmas</span><span class="p">)[</span><span class="n">g_ind</span><span class="p">]</span>
        <span class="n">g_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g_indices</span><span class="p">)[</span><span class="n">g_ind</span><span class="p">]</span>
        <span class="n">g_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g_counts</span><span class="p">)[</span><span class="n">g_ind</span><span class="p">]</span>
        <span class="n">g_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g_offsets</span><span class="p">)[</span><span class="n">g_ind</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_last_result</span> <span class="o">=</span> <span class="n">DetectionResult</span><span class="p">(</span>
            <span class="n">centers</span><span class="o">=</span><span class="n">g_centers</span><span class="p">,</span>
            <span class="n">sigmas</span><span class="o">=</span><span class="n">g_sigmas</span><span class="p">,</span>
            <span class="n">scores</span><span class="o">=</span><span class="n">g_scores</span><span class="p">,</span>
            <span class="n">counts</span><span class="o">=</span><span class="n">g_counts</span><span class="p">,</span>
            <span class="n">edges</span><span class="o">=</span><span class="n">g_edges</span><span class="p">,</span>
            <span class="n">offsets</span><span class="o">=</span><span class="n">g_offsets</span><span class="p">,</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">g_indices</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># to avoid any kind of array change issue</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_result</span><span class="p">)</span></div>

<div class="viewcode-block" id="CountPeakDetector.plot"><a class="viewcode-back" href="../../scludam.detection.html#scludam.detection.CountPeakDetector.plot">[docs]</a>    <span class="nd">@beartype</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">peak</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span>
        <span class="n">cols</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cut_label_prec</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">center_label_prec</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a plot of the individual peaks detected.</span>

<span class="sd">        Creates the plot using the result of the last</span>
<span class="sd">        :func:`~scludam.detection.CountPeakDetector.detect` call.</span>
<span class="sd">        Returns a custom seaborn heatmap plot. Passes any kwargs</span>
<span class="sd">        to the plot function. The heatmap is a two dimensional</span>
<span class="sd">        histogram slice, where x and y can be set, and the rest</span>
<span class="sd">        of dimensions are fixed in the peak center.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        peak : int, optional</span>
<span class="sd">            Index of the peak to be plotted in the result array,</span>
<span class="sd">            by default 0</span>
<span class="sd">        x : int, optional</span>
<span class="sd">            Index of the variable that should be placed as the</span>
<span class="sd">            first dimension, by default 0</span>
<span class="sd">        y : int, optional</span>
<span class="sd">            Index of the variable that should be placed as the</span>
<span class="sd">            second dimension, by default 1</span>
<span class="sd">        mode : str, optional</span>
<span class="sd">            Histogram type, by default &quot;c&quot;. Can be one of:</span>

<span class="sd">            #. &quot;c&quot;: Counts histogram.</span>
<span class="sd">            #. &quot;b&quot;: Background histogram.</span>
<span class="sd">            #. &quot;e&quot;: Excess histogram.</span>
<span class="sd">            #. &quot;s&quot;: Score histogram.</span>

<span class="sd">            The meaning of each histogram can be inferred from the</span>
<span class="sd">            method explained in</span>
<span class="sd">            :class:`~scludam.detection.CountPeakDetector`.</span>

<span class="sd">        cols : Union[[List[str]], None], optional</span>
<span class="sd">            List of variable names, by default ``None``. If ``None``,</span>
<span class="sd">            then the variables are called &#39;var1&#39;, &#39;var2&#39;, and so on.</span>
<span class="sd">        cut_label_prec : int, optional</span>
<span class="sd">            Decimal places for the cut message in the title, by default 4.</span>
<span class="sd">        center_label_prec : int, optional</span>
<span class="sd">            Decimal places for the center message in the title, by default 4.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.axes._subplots.AxesSubplot</span>
<span class="sd">            Plot of the peak.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If no results are available.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If no peaks are detected in the last result.</span>
<span class="sd">        ValueError</span>
<span class="sd">            Invalid peak index.</span>
<span class="sd">        ValueError</span>
<span class="sd">            Invalid mode.</span>
<span class="sd">        ValueError</span>
<span class="sd">            Invalid x or y dimensions.</span>
<span class="sd">        ValueError</span>
<span class="sd">            Invalid label length.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. literalinclude:: ../../examples/detection/plot.py</span>
<span class="sd">            :language: python</span>
<span class="sd">            :linenos:</span>
<span class="sd">        .. image:: ../../examples/detection/plot1.png</span>
<span class="sd">        .. image:: ../../examples/detection/plot2.png</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No result available, run detect function first.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_result</span><span class="o">.</span><span class="n">centers</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No peaks detected in last run.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_result</span><span class="o">.</span><span class="n">centers</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">peak</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No peak with index </span><span class="si">{</span><span class="n">peak</span><span class="si">}</span><span class="s2"> detected in last run.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mode must be one of &#39;c&#39;, &#39;b&#39;, &#39;e&#39; or &#39;s&#39;.&quot;</span><span class="p">)</span>

        <span class="n">pindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_result</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">peak</span><span class="p">]</span>
        <span class="n">pcenter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_result</span><span class="o">.</span><span class="n">centers</span><span class="p">[</span><span class="n">peak</span><span class="p">]</span>

        <span class="n">hist</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_result</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="n">peak</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># duplicated code, pay attention if the method is changed in detect function</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>
            <span class="n">smoothed</span> <span class="o">=</span> <span class="n">_convolve</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span>
                <span class="n">sharp</span> <span class="o">=</span> <span class="n">hist</span> <span class="o">-</span> <span class="n">smoothed</span>
                <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;e&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_mode</span> <span class="o">==</span> <span class="s2">&quot;approx&quot;</span><span class="p">:</span>
                        <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">smoothed</span> <span class="o">+</span> <span class="n">hist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_mode</span> <span class="o">==</span> <span class="s2">&quot;std&quot;</span><span class="p">:</span>
                        <span class="n">std</span> <span class="o">=</span> <span class="n">fast_std_filter</span><span class="p">(</span><span class="n">sharp</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">normalized</span> <span class="o">=</span> <span class="n">sharp</span> <span class="o">/</span> <span class="n">std</span>
                    <span class="n">hist</span> <span class="o">=</span> <span class="n">normalized</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">hist</span> <span class="o">=</span> <span class="n">sharp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hist</span> <span class="o">=</span> <span class="n">smoothed</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="p">)</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span> <span class="ow">or</span> <span class="n">y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y must be valid dimensions.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;var</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cols must have n_dim elements.&quot;</span><span class="p">)</span>

        <span class="c1"># flip xy order because heatmap plots yx instead of xy</span>
        <span class="n">xydims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">dims</span><span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]])</span>
        <span class="n">cutdims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">xydims</span><span class="p">)))</span>

        <span class="c1"># transpose the axes so xy are first</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">xydims</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">cutdims</span><span class="p">))</span>

        <span class="c1"># create a 2d cut for (x,y) with the other dims fixed</span>
        <span class="c1"># on the peak value</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hist</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">hist2D</span> <span class="o">=</span> <span class="n">hist</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pindex</span><span class="p">[</span><span class="n">cutdims</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>
            <span class="n">hist2D</span> <span class="o">=</span> <span class="n">hist</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cut</span><span class="p">)]</span>

        <span class="c1"># get the edges of the 2d cut in the xy order</span>
        <span class="n">edges2D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;object&quot;</span><span class="p">)[</span><span class="n">xydims</span><span class="p">]</span>

        <span class="k">assert</span> <span class="n">hist2D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">edges2D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># get the peak indices in the 2d cut in the xy order</span>
        <span class="n">pindex2D</span> <span class="o">=</span> <span class="n">pindex</span><span class="p">[</span><span class="n">xydims</span><span class="p">]</span>

        <span class="c1"># get the bin_shape for xy in the correct order</span>
        <span class="n">bin_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="o">.</span><span class="n">copy</span><span class="p">()[</span><span class="n">xydims</span><span class="p">]</span>

        <span class="n">hm</span> <span class="o">=</span> <span class="n">heatmap2D</span><span class="p">(</span>
            <span class="n">hist2D</span><span class="o">=</span><span class="n">hist2D</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">edges2D</span><span class="p">,</span> <span class="n">bin_shape</span><span class="o">=</span><span class="n">bin_shape</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">pindex2D</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="n">hm</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="n">hm</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="n">y</span><span class="p">])</span>

        <span class="n">cut_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">pcenter</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cut_label_prec</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
        <span class="n">cut_edges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cut_label_prec</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
        <span class="n">cut_string</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">cut_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">±</span><span class="si">{</span><span class="n">cut_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cutdims</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">mode_string</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="s2">&quot;Count histogram&quot;</span><span class="p">,</span>
            <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="s2">&quot;Background histogram&quot;</span><span class="p">,</span>
            <span class="s2">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;Excess histogram&quot;</span><span class="p">,</span>
            <span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="s2">&quot;Score histogram&quot;</span><span class="p">,</span>
        <span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="s2">&quot;Count histogram&quot;</span><span class="p">)</span>

        <span class="n">pcenter_string</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">pcenter</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">cut_label_prec</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">hm</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">set_style</span><span class="p">(</span><span class="s2">&quot;italic&quot;</span><span class="p">)</span>
        <span class="n">hm</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span>
            <span class="n">mode_string</span>
            <span class="o">+</span> <span class="s2">&quot; sliced at &quot;</span>
            <span class="o">+</span> <span class="n">cut_string</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">peak&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;=(&quot;</span>
            <span class="o">+</span> <span class="n">pcenter_string</span>
            <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">hm</span></div>

<div class="viewcode-block" id="CountPeakDetector.lineplot"><a class="viewcode-back" href="../../scludam.detection.html#scludam.detection.CountPeakDetector.lineplot">[docs]</a>    <span class="k">def</span> <span class="nf">lineplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the last result as a line plot.</span>

<span class="sd">        Plots scores and counts for all peaks found.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AxesSubplot</span>
<span class="sd">            Line plot of the scores and counts.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            No results available.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No result available, run detect function first.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">horizontal_lineplots</span><span class="p">(</span>
            <span class="n">ys</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_result</span><span class="o">.</span><span class="n">scores</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_result</span><span class="o">.</span><span class="n">counts</span><span class="p">],</span>
            <span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;scores&quot;</span><span class="p">,</span> <span class="s2">&quot;counts&quot;</span><span class="p">],</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Simón Pedro González.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>